# make_qc_notebook.py
# Loob valmis Jupyter notebooki projekti scripts/ kausta (Europe/Tallinn 00–23 paneelid + hajuvus)

import json
from pathlib import Path

nb = {
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# QC Panels — Our vs Actual vs Plan (Europe/Tallinn)\n",
    "\n",
    "See notebook joonistab **3×3 päevapaneelid** (kohalik aeg Europe/Tallinn, 00–23) ning eraldi **viimase päeva hajuvuse**:\n",
    "\n",
    "- Paneel: *Actual vs Our* (+ *Plan snapshot*, kui saadaval)\n",
    "- Snapshot loogika: iga päeva jaoks kasutatakse **värskeimat enne päeva** salvestatud Eleringi plaani CSV-d\n",
    "- Filtrid: ainult tööpäevad / nädalavahetus / kõik\n",
    "- Väljundid salvestatakse `scripts/plots` kausta\n",
    "\n",
    "⚠️ Eeldab, et sul on olemas projektis järgmised failid:\n",
    "- `scripts/forecast_vs_actual_comparison_hourly.csv` (või `_enriched.csv`) – meie forecast + actual (ja ideaalis ka plaan)\n",
    "- `scripts/elering_forecast_from_YYYYMMDD.csv` – Eleringi plaan snapshot'id\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Seaded ===\n",
    "DAY_FILTER   = \"workdays\"   # \"workdays\" | \"weekends\" | \"all\"\n",
    "REQUIRE_PLAN = True         # kui True: kuva vaid päevad, millel on 24h plaan snapshot'ist\n",
    "N_DAYS       = 7            # mitu viimast päeva paneelile\n",
    "TZ           = \"Europe/Tallinn\"\n",
    "\n",
    "from pathlib import Path\n",
    "import pandas as pd, numpy as np, re, matplotlib.pyplot as plt\n",
    "PLOTS_DIR = Path(\"scripts\") / \"plots\"\n",
    "PLOTS_DIR.mkdir(parents=True, exist_ok=True)\n",
    "print(\"Pildid salvestatakse:\", PLOTS_DIR.resolve())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Lae comparison-andmed robustselt ===\n",
    "from pathlib import Path\n",
    "import pandas as pd\n",
    "\n",
    "comp_main = Path(\"scripts\")/\"forecast_vs_actual_comparison_hourly.csv\"\n",
    "comp_alt  = Path(\"scripts\")/\"forecast_vs_actual_comparison_hourly_enriched.csv\"\n",
    "\n",
    "if comp_main.is_file():\n",
    "    df = pd.read_csv(comp_main, sep=';', encoding='utf-8', low_memory=False)\n",
    "    print(\"Laetud:\", comp_main)\n",
    "elif comp_alt.is_file():\n",
    "    df = pd.read_csv(comp_alt, sep=';', encoding='utf-8', low_memory=False)\n",
    "    print(\"Laetud:\", comp_alt)\n",
    "else:\n",
    "    raise FileNotFoundError(\"Puudub scripts/forecast_vs_actual_comparison_hourly(.csv|_enriched.csv)\")\n",
    "\n",
    "# normalizeeri võimalikud duplikaadid elering_forecast_x/y\n",
    "if 'elering_forecast' not in df.columns and ('elering_forecast_x' in df.columns or 'elering_forecast_y' in df.columns):\n",
    "    df['elering_forecast'] = df.get('elering_forecast_x')\n",
    "    if 'elering_forecast_y' in df.columns:\n",
    "        df['elering_forecast'] = df['elering_forecast'].combine_first(df['elering_forecast_y'])\n",
    "\n",
    "print(\"Veerud:\", list(df.columns)[:12], '...')\n",
    "print(\"Read:\", len(df))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Abi: ajad Tallinna ajaks; base DataFrame ===\n",
    "import pandas as pd\n",
    "\n",
    "def to_local(dt_series, tz=TZ):\n",
    "    s = pd.to_datetime(dt_series, errors=\"coerce\")\n",
    "    if getattr(s.dt, \"tz\", None) is None:\n",
    "        s = s.dt.tz_localize(\"UTC\")\n",
    "    s = s.dt.tz_convert(tz)\n",
    "    return s.dt.tz_localize(None)\n",
    "\n",
    "base = df.copy()\n",
    "if \"datetime_hour\" not in base.columns:\n",
    "    # püüa Ajatempel (UTC) -> sekundid\n",
    "    if 'Ajatempel (UTC)' in base.columns:\n",
    "        ts = pd.to_numeric(base['Ajatempel (UTC)'], errors='coerce')\n",
    "        base['datetime_hour'] = pd.to_datetime(ts, unit='s', utc=True)\n", 
    "    else:\n",
    "        raise ValueError(\"Puudub 'datetime_hour' või 'Ajatempel (UTC)'.\")\n",
    "\n",
    "base['dt_local']  = to_local(base['datetime_hour'])\n",
    "base['day_local'] = base['dt_local'].dt.floor('D')\n",
    "base['hour_local']= base['dt_local'].dt.hour\n",
    "\n",
    "# vali väärtuse veerud\n",
    "col_actual = 'Tarbimine' if 'Tarbimine' in base.columns else ('consumption' if 'consumption' in base.columns else None)\n",
    "col_our    = 'consumption_hourly' if 'consumption_hourly' in base.columns else None\n",
    "col_plan   = 'elering_forecast' if 'elering_forecast' in base.columns else ('plan' if 'plan' in base.columns else None)\n",
    "if not all([col_actual, col_our]):\n",
    "    raise ValueError(f\"Puuduvad veerud: actual={col_actual}, our={col_our}\")\n",
    "\n",
    "for c in [col_actual, col_our] + ([col_plan] if col_plan else []):\n",
    "    if c and c in base.columns:\n",
    "        base[c] = pd.to_numeric(base[c], errors='coerce')\n",
    "\n",
    "used = ['dt_local','day_local','hour_local', col_actual, col_our] + ([col_plan] if col_plan else [])\n",
    "base = base[used].rename(columns={col_actual:'actual', col_our:'our', (col_plan if col_plan else 'dummy'):'plan'}).sort_values(['day_local','hour_local'])\n",
    "if 'plan' not in base.columns:\n",
    "    print('⚠️ NB: comparison-tabelist puudub plaani veerg; plaan võetakse ainult snapshot-failidest.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Snapshot loogika: värskeim enne päeva ===\n",
    "from pathlib import Path\n",
    "import pandas as pd, re\n",
    "\n",
    "PLAN_DIR = Path('scripts')\n",
    "PLAN_GLOB = 'elering_forecast_from_*.csv'\n",
    "\n",
    "def _snapdate_from_name(p: Path):\n",
    "    m = re.search(r'(\\d{8})', p.name)\n",
    "    return pd.to_datetime(m.group(1), format='%Y%m%d') if m else None\n",
    "\n",
    "def plan_snapshot_for_local_day(day_local: pd.Timestamp, tz=TZ):\n",
    "    snaps = sorted(PLAN_DIR.glob(PLAN_GLOB))\n",
    "    if not snaps:\n",
    "        return None\n",
    "    # vali viimane snapshot, mille kuupäev <= päeva kuupäev\n",
    "    candidates = []\n",
    "    for p in snaps:\n",
    "        d = _snapdate_from_name(p)\n",
    "        if d is not None and d.date() <= pd.to_datetime(day_local).date():\n",
    "            candidates.append((d, p))\n",
    "    if not candidates:\n",
    "        return None\n",
    "    _, snap_path = sorted(candidates, key=lambda x: x[0])[-1]\n",
    "    dfp = pd.read_csv(snap_path, sep=';', encoding='utf-8', low_memory=False)\n",
    "    # normaliseeri\n",
    "    if 'Ajatempel (UTC)' in dfp.columns and 'Planeeritud tarbimine' in dfp.columns:\n",
    "        ts = pd.to_numeric(dfp['Ajatempel (UTC)'], errors='coerce')\n",
    "        dt_loc = to_local(pd.to_datetime(ts, unit='s', utc=True), tz=tz)\n",
    "        plan   = pd.to_numeric(dfp['Planeeritud tarbimine'].astype(str).str.replace('\"','').str.replace(' ','').str.replace(',', '.'), errors='coerce')\n",
    "    elif 'timestamp' in dfp.columns and 'plan' in dfp.columns:\n",
    "        dt_loc = to_local(pd.to_datetime(pd.to_numeric(dfp['timestamp'], errors='coerce'), unit='s', utc=True), tz=tz)\n",
    "        plan   = pd.to_numeric(dfp['plan'], errors='coerce')\n",
    "    else:\n",
    "        return None\n",
    "\n",
    "    d0 = pd.to_datetime(day_local).floor('D')\n",
    "    mask = (dt_loc >= d0) & (dt_loc < d0 + pd.Timedelta(days=1))\n",
    "    sub = pd.DataFrame({'hour_local': dt_loc[mask].dt.hour, 'plan_snapshot': plan[mask]}).dropna()\n",
    "    if int(sub['hour_local'].nunique()) != 24:\n",
    "        return None\n",
    "    return sub.sort_values('hour_local').reset_index(drop=True)\n",
    "\n",
    "print('Snapshot helper valmis.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Päevade valik (täis 24h meie prognoosi) + filtrid ===\n",
    "full_days_ours = base.groupby('day_local')['our'].apply(lambda x: x.notna().sum()==24)\n",
    "days_all = sorted([d for d, ok in full_days_ours.items() if ok])\n",
    "\n",
    "def is_workday_local(d):\n",
    "    return pd.to_datetime(d).weekday() < 5\n",
    "\n",
    "if DAY_FILTER == 'workdays':\n",
    "    days_all = [d for d in days_all if is_workday_local(d)]\n",
    "elif DAY_FILTER == 'weekends':\n",
    "    days_all = [d for d in days_all if not is_workday_local(d)]\n",
    "\n",
    "days_all = days_all[-N_DAYS:]\n",
    "\n",
    "if REQUIRE_PLAN:\n",
    "    kept = []\n",
    "    for d in days_all:\n",
    "        if plan_snapshot_for_local_day(d) is not None:\n",
    "            kept.append(d)\n",
    "    days_all = kept\n",
    "\n",
    "if not days_all:\n",
    "    raise RuntimeError('Paneelile ei jäänud ühtegi päeva (filtrid / plaaninõue).')\n",
    "\n",
    "print('Päevi paneelil:', [str(pd.to_datetime(d).date()) for d in days_all])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === 3×3 paneel (kohalik 00–23) ===\n",
    "rows, cols = 3, 3\n",
    "fig, axes = plt.subplots(rows, cols, figsize=(14, 10), sharey=True)\n",
    "axes = axes.flatten()\n",
    "\n",
    "for i, ax in enumerate(axes):\n",
    "    if i < len(days_all):\n",
    "        d = days_all[i]\n",
    "        s = base[base['day_local']==d].sort_values('hour_local')\n",
    "        ps = plan_snapshot_for_local_day(d) if REQUIRE_PLAN else None\n",
    "\n",
    "        ax.plot(s['hour_local'], s['actual'], label='Actual')\n",
    "        ax.plot(s['hour_local'], s['our'],    label='Our')\n",
    "        if ps is not None:\n",
    "            ax.plot(ps['hour_local'], ps['plan_snapshot'], label='Plan (snapshot)', alpha=0.9)\n",
    "\n",
    "        ax.set_title(str(pd.to_datetime(d).date()))\n",
    "        ax.set_xlabel('Tund (Europe/Tallinn)'); ax.set_ylabel('MWh/h')\n",
    "        ax.set_xticks(range(0,24,3)); ax.grid(True, alpha=0.3)\n",
    "    else:\n",
    "        ax.axis('off')\n",
    "\n",
    "handles, labels = axes[0].get_legend_handles_labels()\n",
    "fig.legend(handles, labels, loc='upper center', ncol=3)\n",
    "cap = {'all':'kõik päevad','workdays':'tööpäevad','weekends':'nädalavahetus'}[DAY_FILTER]\n",
    "fig.suptitle(f\"Viimased päevad ({cap}) — kohalik 00–23{' — plaan kohustuslik' if REQUIRE_PLAN else ''}\", y=0.995)\n",
    "fig.tight_layout(rect=[0,0,1,0.97])\n",
    "\n",
    "out_panel = PLOTS_DIR / f\"panel_local_{DAY_FILTER}{'_planreq' if REQUIRE_PLAN else ''}.png\"\n",
    "fig.savefig(out_panel, dpi=144)\n",
    "plt.show()\n",
    "print('Salvestatud:', out_panel)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Viimase päeva hajuvus (Our vs Actual ja Our vs Plan snapshot) — kohalik 00–23 ===\n",
    "last_day = days_all[-1]\n",
    "s = base[base['day_local']==last_day].sort_values('hour_local').copy()\n",
    "ps = plan_snapshot_for_local_day(last_day)\n",
    "if ps is not None:\n",
    "    s = s.merge(ps, on='hour_local', how='left')\n",
    "\n",
    "import numpy as np\n",
    "x = pd.to_numeric(s['our'], errors='coerce')\n",
    "\n",
    "plt.figure(figsize=(6.8,6.8))\n",
    "mins, maxs = [], []\n",
    "\n",
    "# Our vs Actual\n",
    "ya = pd.to_numeric(s['actual'], errors='coerce')\n",
    "mA = x.notna() & ya.notna()\n",
    "if int(mA.sum())>0:\n",
    "    plt.scatter(x[mA], ya[mA], s=24, alpha=0.75, label=f\"vs Actual — N={int(mA.sum())}\")\n",
    "    mins += [x[mA].min(), ya[mA].min()]; maxs += [x[mA].max(), ya[mA].max()]\n",
    "\n",
    "# Our vs Plan (snapshot)\n",
    "if 'plan_snapshot' in s.columns:\n",
    "    yp = pd.to_numeric(s['plan_snapshot'], errors='coerce')\n",
    "    mP = x.notna() & yp.notna()\n",
    "    if int(mP.sum())>0:\n",
    "        plt.scatter(x[mP], yp[mP], s=24, alpha=0.75, label=f\"vs Plan (snapshot) — N={int(mP.sum())}\")\n",
    "        mins += [x[mP].min(), yp[mP].min()]; maxs += [x[mP].max(), yp[mP].max()]\n",
    "\n",
    "if mins and maxs:\n",
    "    lo, hi = float(np.nanmin(mins)), float(np.nanmax(maxs))\n",
    "    plt.plot([lo,hi],[lo,hi],'k--',lw=1,label='y=x')\n",
    "    plt.xlim(lo,hi); plt.ylim(lo,hi)\n",
    "\n",
    "plt.title(f\"Hajuvus — {pd.to_datetime(last_day).date()} (Europe/Tallinn 00–23)\")\n",
    "plt.xlabel('Our (MWh/h)'); plt.ylabel('Võrdlus (MWh/h)')\n",
    "plt.legend(); plt.tight_layout()\n",
    "out_sc = PLOTS_DIR / f\"scatter_lastday_local{'_planreq' if REQUIRE_PLAN else ''}.png\"\n",
    "plt.savefig(out_sc, dpi=144); plt.show(); print('Salvestatud:', out_sc)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "metadata": {},
   "outputs": [],
   "source": [
    "# === Päevamõõdikud tabelina ===\n",
    "def daily_metrics_local(d):\n",
    "    s = base[base['day_local']==d].sort_values('hour_local')\n",
    "    err_abs = (s['our'] - s['actual']).abs()\n",
    "    return {\n",
    "        'day_local': pd.to_datetime(d).date(),\n",
    "        'N': int(err_abs.notna().sum()),\n",
    "        'avg_abs_err_MWh': float(err_abs.mean()),\n",
    "        'max_abs_err_MWh': float(err_abs.max()),\n",
    "        'min_abs_err_MWh': float(err_abs.min()),\n",
    "    }\n",
    "\n",
    "metrics = pd.DataFrame([daily_metrics_local(d) for d in days_all])\n",
    "display(metrics)\n",
    "metrics_path = PLOTS_DIR / f\"daily_metrics_local_{DAY_FILTER}.csv\"\n",
    "metrics.to_csv(metrics_path, sep=';', index=False, encoding='utf-8')\n",
    "print('Salvestatud:', metrics_path)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "name": "python",
   "version": "3.x"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

# Salvesta projekti scripts/ kausta
out_dir = Path("scripts")
out_dir.mkdir(parents=True, exist_ok=True)
out_path = out_dir / "QC_Panels_Local_Tallinn.ipynb"
with open(out_path, "w", encoding="utf-8") as f:
    json.dump(nb, f, ensure_ascii=False, indent=2)

print("Notebook loodud:", out_path.resolve())
